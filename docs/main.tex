\documentclass[12pt]{article}
\usepackage[lmargin=1in, rmargin=1in, bmargin=1in, tmargin=1in, papersize={8.50in,11.00in}]{geometry}

\usepackage{dsm5}

\setTitle{\OKL: A Unified Kernel Language for Parallel Architectures}

\addAuthor{
  David S. Medina\footnote{David S. Medina, Computational and Applied Mathematics at Rice University (dsm5@rice.edu)}
}

\addAuthor{
  Amik St-Cyr\footnote{Amik St-Cyr, HPC Development Lead  at Shell  (Amik.St-Cyr@shell.com)}
}

\addAuthor{
  Tim Warburton\footnote{Tim Warburton, Computational and Applied Mathematics at Rice University (timwar@rice.edu)}
}

\addAuthor{
  Lucas Wilcox\footnote{Lucas Wilcox, Department of Applied Mathematics at Naval Postgraduate School (lwilcox@nps.edu)}
}

\begin{document}

\pagestyle{empty}

\placeTitlePage

The inability to predict lasting languages and architectures led us to develop \occa, a library focused on host-device interaction.
\occa is made up of a portable API, natively available in C, C\tf{++}, C\tf{\#}, Fortran, Python, Julia and MATLAB, and the device kernel language.
The unified kernel language in \occa is based on macro expansions exposing parallelism and expanding to OpenMP, OpenCL, CUDA, Pthreads and COI.

However, rather than coding in the \occa intermediate representation, we introduce two native languages: \okl and \ofl.
The \occa Kernel Language (\okl) is based on C and extends the language by exposing parallel loops by labeling them.
The \occa Fortran Language (\ofl) is the Fortran language equivalent of \okl.
Simple examples of both, \okl and \ofl, can be seen in \refLst{addVectors} and \refLst{ofl_addVectors}.

\okl/\ofl are loaded and compiled at run-time, allowing for the target language to be chosen at run-time.
Additional features include:
\begin{itemize}
\item Embedded C+\okl and Fortran+\ofl
\item Support for the shared-memory model for GPU-architectures
\item Support for multiple outer-loops per kernel (auto-kernel generation and launching)
\item Automatic detection of work-group/work-item (block/thread) sizes
\item Auto-translates basic OpenCL/CUDA kernels to \okl/\ofl
\item Auto-barrier insertion between inner-loops
\end{itemize}

In my talk, I will be discussing current features that attempt to ease programmers into parallel programming without sacrificing peak efficiency.
To showcase the preservation of computational efficiency, I will show results for high-order finite difference and high-order discontinuous Galerkin method implementations for reverse time migration.
\newpage

\setCode{OKL,none,\scriptsize}
\vspace{4mm}
\begin{lstlisting}[caption={Adding two vectors using the \occa Kernel Language (\okl)},label={lst:addVectors}]
kernel void addVectors(int entries, const float *a, const float *b, float *ab){
  for(int group = 0; group < entries; group += 16; outer0){
    for(int item = 0; item < 16; ++item; inner0){
      const int n = (item + (16 * group));

      if(n < entries)
        ab[n] = a[n] + b[n];
    }
  }
}
\end{lstlisting}

\setCode{OFL,none,\scriptsize}
\vspace{4mm}
\begin{lstlisting}[caption={Adding two vectors using the \occa Fortran Language (\ofl)},label={lst:ofl_addVectors}]
kernel subroutine addVectors(entries, a, b, ab)
  implicit none

  integer(4), intent(in)  :: entries
  real(4)   , intent(in)  :: a(:), b(:)
  real(4)   , intent(out) :: ab(:)

  integer :: group, item, n

  do group = 1, entries, 16, outer0
     do item = 1, 16, inner0
        n = (item + (16 * (group - 1)))

        if (n < entries) then
           ab(n) = a(n) + b(n)
        end if
     end do
  end do

end subroutine addVectors
\end{lstlisting}

\end{document}