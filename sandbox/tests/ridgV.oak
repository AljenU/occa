#define p_Np          2
#define p_Npad        3
#define p_Nfields     5
#define p_KblkV       7
#define p_Nparameters 11

#define rx s_vgeofacs[0][kx]
#define ry s_vgeofacs[1][kx]
#define rz s_vgeofacs[2][kx]
#define sx s_vgeofacs[3][kx]
#define sy s_vgeofacs[4][kx]
#define sz s_vgeofacs[5][kx]
#define tx s_vgeofacs[6][kx]
#define ty s_vgeofacs[7][kx]
#define tz s_vgeofacs[8][kx]

typedef float  datafloat;
typedef float4 datafloat4;

kernel void acousticsVolumeKernelNew(const int  K,
                                     const int  Klev,
                                     const int  timeDirection,
                                     const int        * ks,
                                     const datafloat4 * Drst,
                                     const datafloat  * vgeofacs,
                                     const datafloat4 * xyz,
                                     const int        * PTypes,
                                     const datafloat  * paramDB,
                                     const datafloat  * Q,
                                     datafloat  * rhsQ0,
                                     datafloat  * rhsQ1,
                                     datafloat  * rhsQ2){

  for(int ky=0; ky<(Klev+p_KblkV-1)/p_KblkV; ++ky){ // ky [Stride: 1, Bounds: [0, (Klev+p_KblkV-1)/p_KblkV]]

    datafloat s_p[p_KblkV][p_Np];
    datafloat s_UdotGr[p_KblkV][p_Np];
    datafloat s_UdotGs[p_KblkV][p_Np];
    datafloat s_UdotGt[p_KblkV][p_Np];

    datafloat s_vgeofacs[9][p_KblkV];

    int k, active;

    for(int kx=0; kx<p_KblkV; ++kx){ // kx [Stride: 1, Bounds: [0, p_KblkV]]
      for(int n=0; n<p_Np; ++n){     // n  [Stride: 1, Bounds: [0, p_Np]   ]

        k = kx + ky*p_KblkV;         // Depends on kx, ky
                                     // ky -> ky*[kx.stride,...] -> + kx -> independent
        active = (k < Klev);

        if(active){
          if(Klev != K)
            k = ks[k]-1;

          /// fetch constant geometric factors
          int m = n;
          while(m < 9){ /// watch out for N=1 and N=2
            s_vgeofacs[m][kx] = vgeofacs[m + 9*k];
            m += p_Np;
          }

        }
      }
    }

    for(int kx=0; kx<p_KblkV; ++kx){
      for(int n=0; n<p_Np; ++n){

        if(active){

          /// data parallel read of components of Q at W&B nodes
          int id = n + k*p_Nfields*p_Npad;
          datafloat pn = Q[id]; id+= p_Npad;
          datafloat un = Q[id]; id+= p_Npad;
          datafloat vn = Q[id]; id+= p_Npad;
          datafloat wn = Q[id];

          s_p[kx][n] = pn;
          s_UdotGr[kx][n] = un*rx + vn*ry + wn*rz;  // should store drdx*u + drdy*v +drdz*w
          s_UdotGs[kx][n] = un*sx + vn*sy + wn*sz;  // should store dsdx*u + dsdy*v +dsdz*w
          s_UdotGt[kx][n] = un*tx + vn*ty + wn*tz;  // should store dtdx*u + dtdy*v +dtdz*w

          /// roll history data (rhs1 -> rhs2, rhs0 -> rhs1)
          id = n + k*p_Nfields*p_Npad;
          occaUnroll(p_Nfields)
            for(int fld=0; fld<p_Nfields; ++fld){
              rhsQ2[id] = rhsQ1[id];
              rhsQ1[id] = rhsQ0[id]; id += p_Npad;
            }

        }
      }
    }

    for(int kx=0; kx<p_KblkV; ++kx){
      for(int n=0; n<p_Np; ++n){

        if(active){
          datafloat dpdr = 0, dpds = 0, dpdt = 0, divU = 0;

          /// using local memory for each of the three*two flux functions reduces barriers and loads
          for(int m = 0; m < p_Np; ++m){
            const datafloat4 Drst_nm = Drst[n + m*p_Np];
            const datafloat pn = s_p[kx][m];
            dpdr += Drst_nm.x*pn;
            dpds += Drst_nm.y*pn;
            dpdt += Drst_nm.z*pn;
            divU += Drst_nm.x*s_UdotGr[kx][m];
            divU += Drst_nm.y*s_UdotGs[kx][m];
            divU += Drst_nm.z*s_UdotGt[kx][m];
          }

          datafloat dpdx = rx*dpdr+sx*dpds+tx*dpdt;
          datafloat dpdy = ry*dpdr+sy*dpds+ty*dpdt;
          datafloat dpdz = rz*dpdr+sz*dpds+tz*dpdt;


          /// fetch constant physical parameters
          const int idMedium = PTypes[k*(p_Nfaces+1)];
          const datafloat c   = paramDB[p_Nparameters*idMedium+0];
          const datafloat rho = paramDB[p_Nparameters*idMedium+1];
          const datafloat ccRho = c*c*rho;
          const datafloat invRho = 1.f/rho;

          int id = n + k*p_Nfields*p_Npad;
          rhsQ0[id] = -ccRho * divU; id += p_Npad;
          rhsQ0[id] = -invRho * dpdx; id += p_Npad;
          rhsQ0[id] = -invRho * dpdy; id += p_Npad;
          rhsQ0[id] = -invRho * dpdz;

        }
      }
    }
  }
}
